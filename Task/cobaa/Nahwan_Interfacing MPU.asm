;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Wed Oct 25 2023
; Processor: 80C51
; Compiler:  ASEM-51 (Proteus)
;====================================================================

$NOMOD51
$INCLUDE (8051.MCU)

;====================================================================
; DEFINITIONS
;====================================================================

;====================================================================
; VARIABLES
;====================================================================

;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================

      ; Reset Vector
      org   0000h
      jmp   Start

;====================================================================
; CODE SEGMENT
;====================================================================

      org   0100h
Start:	
      ; Write your code here
      CALL I2C_CONFIG
      
Loop:	
      CALL I2C_GET_XH
      ;MOV R0, #200 ;Calculation test
      CALL CALC
      CALL SERIAL_SEND
      
      jmp Loop
      

SERIAL_SEND:
      MOV SCON,#01010010B
      MOV TMOD,#00100000B
      MOV TH1,#253D
      SETB TR1
      CLR TI
      MOV SBUF,R3
      JNB TI,$
      CLR TR1
      RET
      
;SERIAL_INIT:
      ;MOV SCON,#01010010B
      ;MOV TMOD,#00100000B
      ;MOV TH1,#253D
      ;SETB TR1
      ;RET
      
      
DELAY_50MS:
      MOV TMOD, #00010000B	; TIMER MODE 1
      MOV TL1, #LOW (-50000)
      MOV TL1, #HIGH (-50000)
      CLR TF1
      SETB TR1
      JNB TF1,$
      CLR TR1
      RET
      
CALC:
      ;Angle range to 8 bit scale
      ;Equation: y = 2(192 - x)
      ;Input: R0
      ;Output: R3
      MOV B, R0
      JB B.7, CALC_H
      JNB B.7, CALC_L
      MOV R3, #0FFH
      RET
      ;MOV R0, #64 ;Force minimal value of 64
      
CALC_H:     
      JB B.6, CONTINUE
      MOV R3, #0FFH
      RET
      
CONTINUE:
      CALL SUBSTRACT_HIGH ;Substract 320 - x
      CALL MULTIPLY ;Multiply R1 by 2
      ;Output in R3
      RET
      
CALC_L:     
      CALL SUBSTRACT_LOW ;Substract 64 - x
      CALL MULTIPLY ;Multiply R1 by 2
      ;Output in R3
      RET
      
MULTIPLY: 
       ;Multiply R1 by 2
       MOV A, #2 ;Move 2 into the Accumulator
       MOV B, R1 ;Move R1 into B
       MUL AB   ;Multiply the two values
       MOV R2,B ;Move B (the high-byte) into R2
       MOV R3,A ;Move A (the low-byte) into R3
       JB B.0, MAX_VALUE
       ;Return - answer is now in R2 and R3
       RET
       
MAX_VALUE:
      MOV R3, #0FFH
      RET
      
      
SUBSTRACT_LOW:
	;Subtract 64 by R0
	MOV A, #64  ;Move 64 to accumulator
	CLR C     ;Always clear carry before first subtraction
	SUBB A, R0 ;Subtract 64 by input
	JNB PSW.7, CONTINUE_SUBS ;Check carry flag, if set, force minimum value of 0
	MOV A, #00H
	RET
CONTINUE_SUBS:
	MOV R1, A  ;Move the answer to R1
	 RET
  
  SUBSTRACT_HIGH:
  	;Subtract 320 by R0
	  ;Step 1 of the process
	MOV A, #64  ;Move the 320 into the accumulator
	CLR C     ;Always clear carry before first subtraction
	SUBB A, R0 ;Subtract 320 by input
	MOV R1, A  ;Move the answer to R1
	RET
      
I2C_GET_XH:
      CALL I2C_START
      CALL I2C_POINT_XH
      CALL I2C_READ
      MOV R0, A
      CALL I2C_NACK
      CALL I2C_STOP
      RET

I2C_GET_XL:
      CALL I2C_START
      CALL I2C_POINT_XL
      CALL I2C_READ
      ;MOV R0, A
      CALL I2C_NACK
      CALL I2C_STOP
      RET
      
I2C_READ:
      MOV A, #0D1H
      CALL I2C_SEND
      CALL I2C_ACK
      SETB P2.1
      CALL I2C_RECEIVE
      RET
      
I2C_RECEIVE:
      MOV R6, #00
LOOP_RECEIVE:
      MOV C, P2.1		; C <= SDA
      RLC A
      CALL I2C_CLK
      INC R6
      CJNE R6, #08, LOOP_RECEIVE
      RET
      
I2C_POINT_XH:
      MOV A, #0D0H
      CALL I2C_SEND
      CALL I2C_ACK
      MOV A, #03BH
      ;MOV A, #00H
      CALL I2C_SEND
      CALL I2C_ACK
      CALL I2C_START
      RET
      
I2C_POINT_XL:
      MOV A, #0D0H
      CALL I2C_SEND
      CALL I2C_ACK
      MOV A, #03CH
      CALL I2C_SEND
      CALL I2C_ACK
      CALL I2C_START
      RET
      
I2C_CONFIG:
      CALL I2C_START
      MOV A, #0D0H
      CALL I2C_SEND
      CALL I2C_ACK
      MOV A, #06BH ;Power Management 1
      CALL I2C_SEND
      CALL I2C_ACK
      MOV A, #08H ;Sleep Off, Temp sensor off
      CALL I2C_SEND
      CALL I2C_ACK
      CALL I2C_STOP
      
      CALL I2C_START
      MOV A, #0D0H
      CALL I2C_SEND
      CALL I2C_ACK
      MOV A, #01CH ;Accel config
      CALL I2C_SEND
      CALL I2C_ACK
      MOV A, #00H ; Full scale range +-2g
      CALL I2C_SEND
      CALL I2C_ACK
      CALL I2C_STOP
      RET
      
      
I2C_SEND:
      MOV R6, #08
LOOP_SEND:
      RLC A
      MOV P2.1, C		; SDA <= C
      CALL I2C_CLK
      DEC R6
      CJNE R6, #00, LOOP_SEND
      RET
      
I2C_START:
      SETB P2.1		; SDA = 1
      SETB P2.0		; SCL = 1
      CLR P2.1		; SDA = 0
      CLR P2.0		; SCL = 0
      CALL I2C_DELAY
      RET
      
I2C_STOP:
      CLR P2.1		; SDA = 0
      SETB P2.0		; SCL = 1
      CALL I2C_DELAY
      SETB P2.1		; SDA = 1
      CALL I2C_DELAY
      RET
      
I2C_NACK:
      SETB P2.1		; SDA = 1
      CALL I2C_DELAY
      CALL I2C_CLK
      CALL I2C_DELAY
      RET
      
I2C_ACK:
      CLR P2.1		; SDA = 0
      CALL I2C_DELAY
      CALL I2C_CLK
      CALL I2C_DELAY
      RET
      
I2C_CLK:
      SETB P2.0		; SCL = 1
      CALL I2C_DELAY
      CLR P2.0		; SCL = 0
      CALL I2C_DELAY
      RET 
      
I2C_DELAY:
      MOV R7, #255
LOOP_D:
      DJNZ R7, LOOP_D
      RET      

;====================================================================
      END
